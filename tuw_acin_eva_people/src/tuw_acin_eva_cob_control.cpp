//##################
//#### defines ####
#define MAX_PARAMS 2
#define NO_VALID_REQUEST 0
#define ADD_FACE 1
#define REMOVE_FACE 2
#define RENAME_LABEL 3
#define EIGENFACE_COUNT 50

//#### includes ####
// ROS includes
#include <ros/ros.h>

// Actions
#include <actionlib/client/simple_action_client.h>
#include <cob_people_detection/addDataAction.h>
#include <cob_people_detection/updateDataAction.h>
#include <cob_people_detection/deleteDataAction.h>
#include <cob_people_detection/loadModelAction.h>
#include <cob_people_detection/getDetectionsAction.h>

// services
#include <cob_people_detection/captureImage.h>
#include <cob_people_detection/finishRecording.h>
#include <cob_people_detection/recognitionTrigger.h>
#include <std_srvs/Empty.h>
#include <tuw_acin_eva_people/PeopleCommands.h>

// messages
#include <tuw_acin_eva_msgs/ProcessedCommands.h>
#include <std_msgs/String.h>

// standard includes
#include <string>

//####################
//#### node class ####

typedef actionlib::SimpleActionClient<cob_people_detection::addDataAction> AddDataClient;
typedef actionlib::SimpleActionClient<cob_people_detection::updateDataAction> UpdateDataClient;
typedef actionlib::SimpleActionClient<cob_people_detection::deleteDataAction> DeleteDataClient;
typedef actionlib::SimpleActionClient<cob_people_detection::loadModelAction> LoadModelClient;
typedef actionlib::SimpleActionClient<cob_people_detection::getDetectionsAction> GetDetectionsClient;

void addData(AddDataClient& add_data_client, ros::ServiceClient& capture_image_client, ros::ServiceClient& finish_recording_client, std::string label)
{
	cob_people_detection::addDataGoal goal;
	std::cout << label << std::endl;

    // Name of the captured person
	goal.label = label;

	// Hard coded mode continuous
	goal.capture_mode = 1;

	// Take EIGENFACE_COUNT pictures for Eigenface calculation with 0.5 seconds between them
	goal.continuous_mode_images_to_capture = EIGENFACE_COUNT;
	goal.continuous_mode_delay = 0.5;

	// send goal to server
	add_data_client.sendGoal(goal);
	std::cout << "Recording job was sent to the server ..." << std::endl;

	add_data_client.waitForResult();

	if (add_data_client.getState() == actionlib::SimpleClientGoalState::SUCCEEDED)
		printf("Data recording finished successfully.\n");
	else
		printf("Data recording did not finish successfully.\n");

	printf("Current State: %s Message: %s\n", add_data_client.getState().toString().c_str(), add_data_client.getState().getText().c_str());
}

void updateData(UpdateDataClient& update_data_client, std::string old_label, std::string new_label)
{
	cob_people_detection::updateDataGoal goal;

    // Only make it possile to change the name for all pictures correlating to a label
    // std::cout << "Choose a mode for data update: 1=by index (changes exactly one entry), 2=by label (changes all entries with that label): ";

    goal.update_mode = 2;
	goal.old_label = old_label;
	goal.new_label = new_label;

	// send goal to server
	update_data_client.sendGoal(goal);
	std::cout << "Update job was sent to the server ..." << std::endl;
	update_data_client.waitForResult();

	if (update_data_client.getState() == actionlib::SimpleClientGoalState::SUCCEEDED)
		printf("Data update finished successfully.\n");
	else
		printf("Data update did not finish successfully.\n");

	printf("Current State: %s Message: %s\n", update_data_client.getState().toString().c_str(), update_data_client.getState().getText().c_str());
}

void deleteData(DeleteDataClient& delete_data_client, std::string label)
{
	cob_people_detection::deleteDataGoal goal;

    // std::cout << "Choose a mode for data deletion: 1=by index (deletes exactly one entry), 2=by label (deletes all entries with that label): ";
	goal.delete_mode = 2;
	goal.label = label;

	// send goal to server
	delete_data_client.sendGoal(goal);
	std::cout << "Delete job was sent to the server ..." << std::endl;
	delete_data_client.waitForResult();

	if (delete_data_client.getState() == actionlib::SimpleClientGoalState::SUCCEEDED)
		printf("Data deletion finished successfully.\n");
	else
		printf("Data deletion did not finish successfully.\n");

	printf("Current State: %s   Message: %s\n", delete_data_client.getState().toString().c_str(), delete_data_client.getState().getText().c_str());
}

void loadRecognitionModel(LoadModelClient& load_model_client)
{
	cob_people_detection::loadModelGoal goal;

	std::cout << "Enter the labels that should occur in the recognition model. By sending an empty list, all available data will be used." << std::endl;

	// send goal to server
	load_model_client.sendGoal(goal);
	std::cout << "Recognition model is loaded by the server ..." << std::endl;
	std::cout << "\nA new recognition model is currently loaded or generated by the server. The following labels will be covered: " << std::endl;
	for (int i=0; i<(int)goal.labels.size(); i++)
		std::cout << "   - " << goal.labels[i] << std::endl;

	load_model_client.waitForResult();

	if (load_model_client.getState() == actionlib::SimpleClientGoalState::SUCCEEDED)
		printf("The new recognition model has been successfully loaded.\n");
	else
		printf("Loading a new recognition model was not successful.\n");

	printf("Current State: %s   Message: %s\n", load_model_client.getState().toString().c_str(), load_model_client.getState().getText().c_str());
}

void activateSensorMessageGateway(ros::ServiceClient& sensor_message_gateway_open_client, ros::ServiceClient& sensor_message_gateway_close_client, int open_close)
{
	if (open_close == 1)
	{
		// activate
		cob_people_detection::recognitionTriggerRequest req;
		cob_people_detection::recognitionTriggerResponse res;
        // std::cout << "At which target frame rate (Hz) shall the sensor message gateway operate: ";

		req.target_frame_rate = 25;

		if (sensor_message_gateway_open_client.call(req, res) == true)
			printf("Gateway successfully opened.\n");
		else
			printf("Opening gateway was not successful.\n");
	}
	else if (open_close == 2)
	{
		// deactivate
		std_srvs::Empty rec;
		if (sensor_message_gateway_close_client.call(rec) == true)
			printf("Gateway successfully closed.\n");
		else
			printf("Closing gateway was not successful.\n");
	}
}

void getDetections(GetDetectionsClient& get_detections_client)
{
	cob_people_detection::getDetectionsGoal goal;

	std::cout << "Enter a maximum age of the detection message (in seconds): ";
	std::cin >> goal.maximum_message_age;

	std::cout << "Enter the maximum waiting time to receive the message (in seconds): ";
	std::cin >> goal.timeout;

	// send goal to server
	get_detections_client.sendGoal(goal);
	std::cout << "Waiting for the server to send the detections ..." << std::endl;
	get_detections_client.waitForResult();

	if (get_detections_client.getState() == actionlib::SimpleClientGoalState::SUCCEEDED)
	{
		cob_people_detection::getDetectionsResultConstPtr result = get_detections_client.getResult();
		std::cout << "Received a detection message with " << result->detections.detections.size() << " detections.\nThe labels are" << std::endl;
		for (int i=0; i<(int)result->detections.detections.size(); i++)
			std::cout << "   - " << result->detections.detections[i].label << std::endl;
	}
	else
		std::cout << "No detections received.\n";

	printf("Current State: %s   Message: %s\n", get_detections_client.getState().toString().c_str(), get_detections_client.getState().getText().c_str());
}


bool processPeopleCommands(tuw_acin_eva_people::PeopleCommands::Request &req, tuw_acin_eva_people::PeopleCommands::Response &res, AddDataClient *add_data_client, \
						  ros::ServiceClient *capture_image_client, ros::ServiceClient *finish_recording_client, UpdateDataClient *update_data_client, \
						  LoadModelClient *load_model_client, DeleteDataClient *delete_data_client)
{
	int command = req.command;
	std::string parameters[MAX_PARAMS];
//	std::cout << "Received command: " << command << std::endl;
	for (int i = 0; i < (req.parameters).size(); i++)
	{
///		std::cout << "Received parameters: " << req.parameters[i]  << std::endl;
		parameters[i] = req.parameters[i];
	}

	switch( command )
	{
	case ADD_FACE:
		addData(*add_data_client, *capture_image_client, *finish_recording_client, parameters[0]);
		loadRecognitionModel(*load_model_client);
		break;
	case REMOVE_FACE:
		deleteData(*delete_data_client, parameters[0]);
//		loadRecognitionModel(*load_model_client);
		break;
	case RENAME_LABEL:
		updateData(*update_data_client, parameters[0], parameters[1]);
		loadRecognitionModel(*load_model_client);
		break;
	default:
		ROS_INFO("UNKNOWN command received: command code is: %ld", command);
		break;
	}

	res.status = "Working";
	ROS_INFO("sending back response: %s", res.status.c_str());

	return true;
}

void commandCallback(const tuw_acin_eva_msgs::ProcessedCommands::ConstPtr& msg, AddDataClient *add_data_client,\ 
			ros::ServiceClient *capture_image_client, ros::ServiceClient *finish_recording_client, UpdateDataClient *update_data_client, \
			LoadModelClient *load_model_client, DeleteDataClient *delete_data_client)
{
	int command = msg->command;
	std::string parameters[MAX_PARAMS];
//	std::cout << "Received command: " << command << std::endl;
	for (int i = 0; i < (msg->parameters).size(); i++)
	{
//		std::cout << "Received parameters: " << msg->parameters[i]  << std::endl;
		parameters[i] = msg->parameters[i];
	}

	switch( command )
	{
	case ADD_FACE:
		addData(*add_data_client, *capture_image_client, *finish_recording_client, parameters[0]);
		loadRecognitionModel(*load_model_client);
		break;
	case REMOVE_FACE:
		deleteData(*delete_data_client, parameters[0]);
		break;
	case RENAME_LABEL:
		updateData(*update_data_client, parameters[0], parameters[1]);
		loadRecognitionModel(*load_model_client);
		break;
	default:
		ROS_INFO("UNKNOWN command received: command code is: %ld", command);
		break;
	}
}


int main(int argc, char** argv)
{
	ros::init(argc, argv, "tuw_acin_eva_cob_control");
	ros::NodeHandle nh;

	AddDataClient add_data_client("/cob_people_detection/face_capture/add_data_server", true); // true -> don't need ros::spin()
	ros::ServiceClient capture_image_client = nh.serviceClient<cob_people_detection::captureImage>("/cob_people_detection/face_capture/capture_image");
	ros::ServiceClient finish_recording_client = nh.serviceClient<cob_people_detection::finishRecording>("/cob_people_detection/face_capture/finish_recording");
	UpdateDataClient update_data_client("/cob_people_detection/face_capture/update_data_server", true);
	DeleteDataClient delete_data_client("/cob_people_detection/face_capture/delete_data_server", true);
	LoadModelClient load_model_client("/cob_people_detection/face_recognizer/load_model_server", true);
	GetDetectionsClient get_detections_client("/cob_people_detection/coordinator/get_detections_server", true);
	ros::ServiceClient sensor_message_gateway_open_client = nh.serviceClient<cob_people_detection::recognitionTrigger>("/cob_people_detection/coordinator/start_recognition");
	ros::ServiceClient sensor_message_gateway_close_client = nh.serviceClient<std_srvs::Empty>("/cob_people_detection/coordinator/stop_recognition");

	if (!add_data_client.waitForServer(ros::Duration(2.0)))
	{
		std::cout << "No connection to server 'add_data_server'.\n";
		return 0;
	}
	if (!update_data_client.waitForServer(ros::Duration(2.0)))
	{
		std::cout << "No connection to server 'update_data_server'.\n";
		return 0;
	}
	if (!delete_data_client.waitForServer(ros::Duration(2.0)))
	{
		std::cout << "No connection to server 'delete_data_server'.\n";
		return 0;
	}
	if (!load_model_client.waitForServer(ros::Duration(2.0)))
	{
		std::cout << "No connection to server 'load_model_server'.\n";
		return 0;
	}
	if (!get_detections_client.waitForServer(ros::Duration(2.0)))
	{
		std::cout << "No connection to server 'get_detections_server'.\n";
		return 0;
	}

	std::cout << "Connected to servers.\n";
	activateSensorMessageGateway(sensor_message_gateway_open_client, sensor_message_gateway_close_client, 1);
	std::cout << "Message Gateway open.\n";

	//ros::ServiceServer service = nh.advertiseService<tuw_acin_eva_people::PeopleCommands::Request, tuw_acin_eva_people::PeopleCommands::Response> \
									("process_people_commands", boost::bind(processPeopleCommands, _1, _2, &add_data_client, \
									&capture_image_client, &finish_recording_client, &update_data_client, &load_model_client, &delete_data_client));

	ros::Subscriber sub = nh.subscribe<tuw_acin_eva_msgs::ProcessedCommands> ("/tuw_acin_eva/processed_commands", 1, boost::bind(commandCallback, _1, &add_data_client,\ 
									&capture_image_client, &finish_recording_client, &update_data_client, &load_model_client, &delete_data_client));
	ros::spin();
	activateSensorMessageGateway(sensor_message_gateway_open_client, sensor_message_gateway_close_client, 0);
	std::cout << "Message Gateway closed.\n";
	return 0;
}


